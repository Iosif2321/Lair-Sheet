private fun readRaw(context: Context, @RawRes resId: Int): String =
context.resources.openRawResource(resId).bufferedReader().use { it.readText() }

@Composable
private fun loadRacesFromSources(sources: Set<Ruleset>): List<Race> {
val ctx = LocalContext.current
val json = remember { JSONObject(readRaw(ctx, R.raw.dnd_sources)) } // твой файл :contentReference[oaicite:1]{index=1}

fun key(rs: Ruleset) = when (rs) {
Ruleset.PHB2014 -> "Основные правила 2014"
Ruleset.PHB2024 -> "Основные правила 2024"
Ruleset.EXPANDED -> "Расширенные источники"
}

val acc = mutableListOf<Race>()
sources.forEach { rs ->
json.optJSONObject(key(rs))?.optJSONArray("races")?.let { arr ->
for (i in 0 until arr.length()) {
val o = arr.getJSONObject(i)
val subs = o.optJSONArray("subraces")?.let { sr ->
List(sr.length()) { j ->
val s = sr.getJSONObject(j)
Subrace(nameRu = s.getString("name_ru"), nameEn = s.getString("name_en"))
}
} ?: emptyList()
acc += Race(nameRu = o.getString("name_ru"), nameEn = o.getString("name_en"), subraces = subs)
}
}
}
return acc.distinctBy { it.nameRu } // объединяем выбранные источники по уникальному названию
}

@Composable
fun Step2Screen(
state: CharacterCreationState,
onRaceSelected: (Race) -> Unit,
onNext: () -> Unit
) {
val races = loadRacesFromSources(state.selectedSources)

Column(
Modifier
.fillMaxSize()
.padding(16.dp)
.navigationBarsPadding()
) {
Text("Шаг 2: раса", style = MaterialTheme.typography.headlineSmall)
Spacer(Modifier.height(16.dp))

if (races.isEmpty()) {
Text("Нет доступных рас для выбранных источников")
} else {
LazyColumn(Modifier.weight(1f)) {
items(races) { race ->
ListItem(
headlineContent = { Text(race.nameRu) },
supportingContent = {
if (race.subraces.isNotEmpty())
Text(race.subraces.joinToString { it.nameRu })
},
modifier = Modifier.clickable { onRaceSelected(race) }
)
Divider()
}
}
}

Button(
enabled = state.selectedRace != null,
onClick = onNext,
modifier = Modifier.align(Alignment.End)
) { Text("Далее") }
}
}
